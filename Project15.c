#include "include/connect_user.h"/*Prototipos de funciones*/int open_socket();int bind_to_port(int, int);void connection_handler(User *);int main(int argc, char **argv){	const int PORT = 7200;	int user_socket;		int listener = open_socket();	if(listener == -1){		printf("Error en listener \n");		return 1;	}	//puts("Socket created");	if(bind_to_port(listener, PORT)==-1)		return 1;		if(listen(listener,LISTENQ) == -1){		printf("No se puede conectar nadie mas \n");		return 1;	}	printf("Enlazando al puerto o [Presione CTRL+C para salir.]\n");	printf("Esperando al cliente\n");		struct sockaddr_in client;	socklen_t addres_size = sizeof(client);		user_list = empty_user_list();    pthread_mutex_init(&user_list_mutex, NULL);	User *new_user;		while((user_socket = accept(listener, (struct sockaddr*)&client, &addres_size))){		printf("Esperando al cliente\n");					//Reply to the client		char *message = "Hola Cliente, te pasare al manejador de conexion\n";        write(user_socket , message , strlen(message));				pthread_mutex_lock(&user_list_mutex);				user_list = add_user(user_list, DUMMY_USER, inet_ntoa(client.sin_addr),                             length(user_list), DUMMY_CHANNEL,                             user_socket);							 		pthread_mutex_unlock(&user_list_mutex);		new_user = user_list->payload;				if( pthread_create( &(new_user->thread), NULL ,  (void * (*) (void *)) connection_handler , new_user) < 0){            perror("Error no se puede crear el hilo");            return 1;        }        puts("Manejador asignado");				//char* msg = "hola";		//send(user_socket,msg,strlen(msg),0); /* Servidor envia un mensaje*/		//char server_reply[2000];		//recv(user_socket, server_reply , 2000 , 0); /*cliente responde y lo coloca en server_reply*/		//puts(server_reply); 	}		if(user_socket < 0){		printf("No se puede conectar socket secundario\n");		return 1;	}		return 0;	}/* This will handle connection for each client */void connection_handler(User *user){    //Get the socket descriptor    //int sock = *(int*)user;	int sock = user->socket;	int read_size;    char *message, client_message[2000];         //Send some messages to the client    message = "Soy el Manejador de conexion:: Yo me comunicare con usted\n";    write(sock , message , strlen(message));		message = "Ahora escriba algo \n";    write(sock , message , strlen(message));     	 //Receive a message from client    while( (read_size = recv(sock , client_message , 2000 , 0)) > 0 ){        //Enviar respuesta al cliente		message = "Su mensaje fue recibido, continue escribiendo algo\n";        write(sock , message , strlen(message));	//clear the message buffer	memset(client_message, 0, 2000);    }         if(read_size == 0){        puts("Cliente Desconectado");        fflush(stdout);    }    else if(read_size == -1){        perror("comunicacion fallida");    }          //return 0;}/*Implementacion del socket*/int open_socket(){	int s = socket(AF_INET,SOCK_STREAM,0); /* AF = Dirección de la Familia, PF = Protocolo de Familia, SOCK_STREAM connection oriented*/	if(s == -1)		printf("Error al abrir socket\n");	return s;}int bind_to_port(int socket, int port){	//Prepare the sockaddr_in structure	struct sockaddr_in server;  		bzero(&server, sizeof(server));	server.sin_family	= AF_INET;	server.sin_port = (in_port_t)htons(port);	server.sin_addr.s_addr = htonl(INADDR_ANY);		/*Avoid probles reusing the port*/	int reuse = 1;	if(setsockopt(socket,SOL_SOCKET,SO_REUSEADDR,(char*)&reuse,sizeof(int))==-1){		perror("No es posible reusar el sockets\n");		return -1;	}	/* bind() elegirá un puerto aleatoriamente */    if( bind(socket,(struct sockaddr *)&server , sizeof(server)) < 0){		perror("No se puede enlazar al puerto : direccion ya esta en uso \n");		return -1;	}    //puts("bind done");	return 0;}